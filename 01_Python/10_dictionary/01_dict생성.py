#1. 딕셔너리 생성
# - 집합적 자료, 순서 의미가 없음
# - 키(key):값(value)으로 구성되어 있음
#{key1:vakue1, key2:value2, ...}
# {} 또는 dict() 함수를 이용하여 생성
# key로 데이터를 접근

# d = {} #방법1
d = dict() #방법2
print(d, type(d))
#결과: {} <class 'dict'>

d2 = {1:'a', 2:'b', 3:'c'}
print(d2)
#key의 순서는 의미가 없으나 생성된 순서대로 구성
#key와 value는 사용자가 지정함, 규정이 없다
#key는 숫자, 문자열 다 가능하나 유일하게* 구별되어야 함
#key 중복되면 안됨 value는 중복 가능


#2. 딕셔너리 요소 접근: key를 사용
#딕셔너리[키이름]

#키로 접근하여 값을 가져옴
print(d2[1]) #결과: a / 1은 인덱스가 아닌 key값
#print(d2[0]) #KeyError: 0 발생 / 없는 key라서


#3. 키를 이용하여 접근, 값을 변경 가능함
d2[1] = 10 #키 1을 10으로 바꿈
print(d2)
#결과: {1: 10, 2: 'b', 3: 'c'}


#4. 딕셔너리의 요소 추가 : 딕셔너리[키] = 값
d2[4] = 100
print(d2)
#결과: {1: 10, 2: 'b', 3: 'c', 4: 100}


#5. 키는 유일한 값
#동일한 키 값을 추가하는 경우 맨 마지막에 입력한 키가 적용됨
d3 = {'a':1, 'b':100, 'c': 'hello', 'b': 1000}
print(d3)
#결과: {'a': 1, 'b': 1000, 'c': 'hello'}


#6. 값(value)은 하나, 여러개의 집합적 자료를 가질 수 있다(문자열, 리스트, 튜플 등)
d4 = {'name': ['kim', 'hong','lee'], #리스트 형태
      'score':[100, 90, 80],
      'gender':['F','M','M'],
      'phone':('123-234', '123-9092')} #튜플 형태로 데이터 가질 수 있음

print(d4)
print(d4['name']) #결과: ['kim', 'hong', 'lee']


# 7. 요소 삭제: del(딕셔너리[키])
del(d4['gender'])
print(d4)
#결과: {'name': ['kim', 'hong', 'lee'], 'score': [100, 90, 80], 'phone': ('123-234', '123-9092')}

